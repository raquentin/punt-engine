{"index":{"title":"Welcome","links":["notes/the-punt-engine-system"],"tags":[],"content":"This site hosts documentation on punt-engine, a high-frequency trading engine build for FPGAs and maintained by Trading @ Georgia Tech.\nObjective\nAs a team of undergraduates on a $200 FPGA with a bankroll stimmed largely by microstakes poker winnings, we can safely attribute any profits generated from this infrastructure to good fortune. A better goal here is to build some of the first well-documented open source software in this genre.\nOverview\n\nUnderstand more of this image in The Punt Engine system.\nContributing\nAll contributors are welcome. Begin by reading some of this site and looking through open issues tagged “help wanted”.\nMany modules within our monorepo have dedicated pages here listing dependencies and local dev instructions, find them using the search bar.\nThere will inevitably be holes in the docs. If you have questions or want guidance, we hold office hours in our Discord on Tuesday, Thursday, and Saturday from 9:30am to 12:00pm EDT/UTC-4.\nYou can direct other questions to race@raquent.in."},"notes/contributing-to-the-docs-site":{"title":"Contributing to the docs site","links":[],"tags":[],"content":"This is a walkthrough on how to clone this site, write a note, run the site on local, and update remote.\nDependencies\n\nnode v20\nnpm v9.3.1\ngit\na GitHub account\n\nNewer versions will likely work.\nCloning and running the site\npunt-engine is a monorepo, the docsite sits in a folder with all other modules in the engine.\nClone the entire thing and enter the docs folder:\ngit clone github.com/raquentin/punt-engine.git \\\ncd punt-engine/docs\nIn this folder, you’ll need to use node to install dependencies and run the build script:\nnpm i \\\nnpx quartz build --serve\nYou should have output in console directing you to http://localhost:8080. Open it in a browser and you’ll see the /docs site running locally.\nWriting a note\nBefore editing the repo, make a new branch:\ngit checkout -b &lt;branch-name&gt;\nIf you’re updating the docs to reflect changes in a new pr, just do this in the branch you’re already in.\nNavigate to punt-engine/docs/content/notes. You’ll see many notes, including this one. Touch a new one with a descriptive file name, perhaps the same as the title. This file name is that same path that will be in the URL.\nWith this file touched, you can go back to the browser and open it up, you’ll see a blank page to build on.\nHeader\nEach note needs a header defining its formatted title and date. The header for this note is:\n---\ntitle: Local Docsite Development\ndate: 10-15-2024\n---\nWrite yours similarly.\nBody Features\nI’ll quickly show some features you can do in these markdown files.\nLaTeX\nYou can write latex:\n$a - b &lt; b[a/b] &lt;= a$\nbecomes\na - b &lt; b[a/b] &lt;= a\nCode\nYou can write code:\n    ```haskell\n    topEntity :: Clock System -&gt; Reset System -&gt; Enable System -&gt; Signal System (Int, Int) -&gt; Signal System Int\n    topEntity = exposeClockResetEnable accumulatorMealy\n    ```\nbecomes\ntopEntity :: Clock System -&gt; Reset System -&gt; Enable System -&gt; Signal System (Int, Int) -&gt; Signal System Int\ntopEntity = exposeClockResetEnable accumulatorMealy\nMarkdown\nThese files are written in markdown, which has many formatting features. See this markdown cheat sheet.\nYou can also inspect the source of other notes and see how they’re constructed in the browser.\nUpdating remote\nWith your note finished on local, git push it, make a pr, and it will be reviewed. This site will update when it’s merged."},"notes/index":{"title":"Notes","links":[],"tags":[],"content":""},"notes/the-punt-engine-system":{"title":"The Punt Engine system","links":[],"tags":[],"content":"Exchange\n\nKraken is the trading platform we are connected to. It send and receives market data over network using FIX (Financial Information Exchange) protocol. This protocol is standard for exchanging financial information between the client and exchange. FIX messages are composed of fields formatted as Tag=Value pairs where each field is delimited by the ASCII  character. An example of a FIX message can look like:\n8=FIX.4.4|9=176|35=D|49=SENDER_COMP_ID|56=TARGET_COMP_ID|34=2|52=20250221-15:30:00.000|11=ORDERID12345|21=1|55=IBM|54=1|38=100|40=2|44=125.50|59=0|10=128|\nwhere each field specifies some level of information. For example, 35=D message indicates a new, single order or 55=IBM is the ticker of the security. All fields by tag can be found here: www.onixs.biz/fix-dictionary/4.4/fields_by_tag.html\nNetworking\n\nPhysical Layer (PHY) and Media Access Control (MAC)\n\nPHY handles the physical transmission of data over a network medium via wires. In this case, a ethernet cable is the medium for communication.\nMAC layer manages how devices access the network and control data flow on that medium.\nTCP/IP Stack\nAfter the Ethernet frames are received by the MAC, they are passed to a hardware TCP/IP stack.\nThis stack handles the IP addressing/routing and TCP connection management (handshake, etc.)\n\nRead more about OSI Models here: www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/\nFix Parser\n\nThis block is used to understand the FIX protocol format. It receives a FIX message from the TCP/IP stack and extracts relevant fields such as price, quantity, symbol, order type, and more. There are passed into internal data structure inside the FPGA.\nMarket Data Processing\n\nPattern Block: This block applies user-defined “rules” or “triggers” on the incoming market data (for example, “if last price &gt; 100 and volume &gt; 1,000,000, then …”). These rules might be set up in a reconfigurable way, so the FPGA can react to certain market conditions without waiting on the host CPU. Accumulators: These keep running totals or state based on the market data (e.g., rolling volume, moving averages, count of trades in the last X seconds). By keeping these accumulations on-FPGA, you can avoid sending every tick or partial calculation to the CPU. This reduces latency and allows for real-time triggers.\nDecision/Execution: Order Finder &amp; Req Injector\n\nOrder Finder: This is where the logic decides if it’s time to send an order (based on the patterns/triggers and the accumulated data). For example, if a certain pattern is recognized (like a certain price threshold and volume condition) the Order Finder can decide to place a limit or market order. Req Injector: Once the decision to trade is made, this block constructs the actual order message (FIX format) that will go back out to the exchange. It inserts the correct fields (symbol, side, quantity, price, etc.) into a FIX message for the order."}}